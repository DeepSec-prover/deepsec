open Testing_functions
open Testing_parser_functions

(** An element of type [data_verification] must be associated to each tested function. *)
type data_verification =
  {
    data_IO : data_IO; (** The data I/O associated to the function defined in the module [Testing_functions] (ex: [Testing_function.data_IO_Term_Subst_unify]). *)
    name : string; (** The name of the function. This will be use when calling the executatble. We take the convention to indicate the full name of the function (ex : ["Term.Subst.unify"]).*)
    parsing_function : (Lexing.lexbuf -> Testing_grammar.token) -> Lexing.lexbuf -> parser; (** The function generated by the parser for tests defined in the generated module [Testing_grammar] (ex: [Testing_grammar.parse_Term_Subst_unify]). *)
  }

(** {3 Functions to be tested} *)

let data_verification_Term_Subst_unify =
  {
    data_IO = data_IO_Term_Subst_unify;
    name = "Term.Subst.unify";
    parsing_function = Testing_grammar.parse_Term_Subst_unify
  }

let data_verification_Term_Subst_is_matchable =
  {
    data_IO = data_IO_Term_Subst_is_matchable;
    name = "Term.Subst.is_matchable";
    parsing_function = Testing_grammar.parse_Term_Subst_is_matchable
  }

let data_verification_Term_Subst_is_extended_by =
  {
    data_IO = data_IO_Term_Subst_is_extended_by;
    name = "Term.Subst.is_extended_by";
    parsing_function = Testing_grammar.parse_Term_Subst_is_extended_by
  }

let data_verification_Term_Subst_is_equal_equations =
  {
    data_IO = data_IO_Term_Subst_is_equal_equations;
    name = "Term.Subst.is_equal_equations";
    parsing_function = Testing_grammar.parse_Term_Subst_is_equal_equations
  }

let data_verification_Term_Modulo_syntactic_equations_of_equations =
  {
    data_IO = data_IO_Term_Modulo_syntactic_equations_of_equations;
    name = "Term.Modulo.syntactic_equations_of_equations";
    parsing_function = Testing_grammar.parse_Term_Modulo_syntactic_equations_of_equations
  }

let data_verification_Term_Rewrite_rules_normalise =
  {
    data_IO = data_IO_Term_Rewrite_rules_normalise;
    name = "Term.Rewrite_rules.normalise";
    parsing_function = Testing_grammar.parse_Term_Rewrite_rules_normalise
  }

let data_verification_Term_Rewrite_rules_skeletons =
  {
    data_IO = data_IO_Term_Rewrite_rules_skeletons;
    name = "Term.Rewrite_rules.skeletons";
    parsing_function = Testing_grammar.parse_Term_Rewrite_rules_skeletons
  }

let data_verification_Term_Rewrite_rules_generic_rewrite_rules_formula =
  {
    data_IO = data_IO_Term_Rewrite_rules_generic_rewrite_rules_formula;
    name = "Term.Rewrite_rules.generic_rewrite_rules_formula";
    parsing_function = Testing_grammar.parse_Term_Rewrite_rules_generic_rewrite_rules_formula
  }

let data_verification_Data_structure_Eq_implies =
  {
    data_IO = data_IO_Data_structure_Eq_implies;
    name = "Data_structure.Eq.implies";
    parsing_function = Testing_grammar.parse_Data_structure_Eq_implies
  }

let data_verification_Data_structure_Tools_partial_consequence =
  {
    data_IO = data_IO_Data_structure_Tools_partial_consequence;
    name = "Data_structure.Tools.partial_consequence";
    parsing_function = Testing_grammar.parse_Data_structure_Tools_partial_consequence
  }

let data_verification_Data_structure_Tools_partial_consequence_additional =
  {
    data_IO = data_IO_Data_structure_Tools_partial_consequence_additional;
    name = "Data_structure.Tools.partial_consequence_additional";
    parsing_function = Testing_grammar.parse_Data_structure_Tools_partial_consequence_additional
  }

let data_verification_Data_structure_Tools_uniform_consequence =
  {
    data_IO = data_IO_Data_structure_Tools_uniform_consequence;
    name = "Data_structure.Tools.uniform_consequence";
    parsing_function = Testing_grammar.parse_Data_structure_Tools_uniform_consequence
  }

let data_verification_Process_of_expansed_process =
  {
    data_IO = data_IO_Process_of_expansed_process;
    name = "Process.of_expansed_process";
    parsing_function = Testing_grammar.parse_Process_of_expansed_process
  }

let data_verification_Process_next_output =
  {
    data_IO = data_IO_Process_next_output;
    name = "Process.next_output";
    parsing_function = Testing_grammar.parse_Process_next_output
  }

let data_verification_Process_next_input =
  {
    data_IO = data_IO_Process_next_input;
    name = "Process.next_input";
    parsing_function = Testing_grammar.parse_Process_next_input
  }

let data_verification_Constraint_system_mgs =
  {
    data_IO = data_IO_Constraint_system_mgs;
    name = "Constraint_system.mgs";
    parsing_function = Testing_grammar.parse_Constraint_system_mgs
  }

let data_verification_Constraint_system_one_mgs =
  {
    data_IO = data_IO_Constraint_system_one_mgs;
    name = "Constraint_system.one_mgs";
    parsing_function = Testing_grammar.parse_Constraint_system_one_mgs
  }

let data_verification_Constraint_system_simple_of_formula =
  {
    data_IO = data_IO_Constraint_system_simple_of_formula;
    name = "Constraint_system.simple_of_formula";
    parsing_function = Testing_grammar.parse_Constraint_system_simple_of_formula
  }

let data_verification_Constraint_system_simple_of_disequation =
  {
    data_IO = data_IO_Constraint_system_simple_of_disequation;
    name = "Constraint_system.simple_of_disequation";
    parsing_function = Testing_grammar.parse_Constraint_system_simple_of_disequation
  }

let data_verification_Constraint_system_apply_mgs =
  {
    data_IO = data_IO_Constraint_system_apply_mgs;
    name = "Constraint_system.apply_mgs";
    parsing_function = Testing_grammar.parse_Constraint_system_apply_mgs
  }

let data_verification_Constraint_system_apply_mgs_on_formula =
  {
    data_IO = data_IO_Constraint_system_apply_mgs_on_formula;
    name = "Constraint_system.apply_mgs_on_formula";
    parsing_function = Testing_grammar.parse_Constraint_system_apply_mgs_on_formula
  }


let parsing_function rule =
  let f lextoken lex =
    let parse_f = Testing_grammar.parse_Constraint_system_Rule_rules lextoken lex in
    parse_f rule
  in
  f

let data_verification_Constraint_system_Rule_sat =
  {
    data_IO = data_IO_Constraint_system_Rule_sat;
    name = "Constraint_system.Rule.sat";
    parsing_function = parsing_function Constraint_system.Rule.sat
  }

let data_verification_Constraint_system_Rule_sat_disequation =
  {
    data_IO = data_IO_Constraint_system_Rule_sat_disequation;
    name = "Constraint_system.Rule.sat_disequation";
    parsing_function = parsing_function Constraint_system.Rule.sat_disequation
  }

let data_verification_Constraint_system_Rule_sat_formula =
  {
    data_IO = data_IO_Constraint_system_Rule_sat_formula;
    name = "Constraint_system.Rule.sat_formula";
    parsing_function = parsing_function Constraint_system.Rule.sat_formula
  }

let data_verification_Constraint_system_Rule_equality_constructor =
  {
    data_IO = data_IO_Constraint_system_Rule_equality_constructor;
    name = "Constraint_system.Rule.equality_constructor";
    parsing_function = parsing_function Constraint_system.Rule.equality_constructor
  }

let data_verification_Constraint_system_Rule_equality =
  {
    data_IO = data_IO_Constraint_system_Rule_equality;
    name = "Constraint_system.Rule.equality";
    parsing_function = parsing_function Constraint_system.Rule.equality
  }

let data_verification_Constraint_system_Rule_rewrite =
  {
    data_IO = data_IO_Constraint_system_Rule_rewrite;
    name = "Constraint_system.Rule.rewrite";
    parsing_function = parsing_function Constraint_system.Rule.rewrite
  }

let data_verification_Constraint_system_Rule_normalisation =
  {
    data_IO = data_IO_Constraint_system_Rule_normalisation;
    name = "Constraint_system.Rule.normalisation";
    parsing_function = Testing_grammar.parse_Constraint_system_Rule_normalisation
  }

let all_data_verification =
  [
    data_verification_Term_Subst_unify;
    data_verification_Term_Subst_is_matchable;
    data_verification_Term_Subst_is_extended_by;
    data_verification_Term_Subst_is_equal_equations;
    data_verification_Term_Modulo_syntactic_equations_of_equations;
    data_verification_Term_Rewrite_rules_normalise;
    data_verification_Term_Rewrite_rules_skeletons;
    data_verification_Term_Rewrite_rules_generic_rewrite_rules_formula;
    data_verification_Data_structure_Eq_implies;
    data_verification_Data_structure_Tools_partial_consequence;
    data_verification_Data_structure_Tools_partial_consequence_additional;
    data_verification_Data_structure_Tools_uniform_consequence;
    data_verification_Process_of_expansed_process;
    data_verification_Process_next_output;
    data_verification_Process_next_input;
    data_verification_Constraint_system_mgs;
    data_verification_Constraint_system_one_mgs;
    data_verification_Constraint_system_simple_of_formula;
    data_verification_Constraint_system_simple_of_disequation;
    data_verification_Constraint_system_apply_mgs;
    data_verification_Constraint_system_apply_mgs_on_formula;
    data_verification_Constraint_system_Rule_sat;
    data_verification_Constraint_system_Rule_sat_disequation;
    data_verification_Constraint_system_Rule_sat_formula;
    data_verification_Constraint_system_Rule_equality_constructor;
    data_verification_Constraint_system_Rule_equality;
    data_verification_Constraint_system_Rule_rewrite;
    data_verification_Constraint_system_Rule_normalisation
  ]

(** {3 Verification of tests} *)

(** [verify_function data] verifies all the tests for the function associated to [data]. *)
let verify_tests data_verif =
  let nb_of_tests = Hashtbl.length data_verif.data_IO.validated_tests in

  Printf.printf "Testing the function %s..." data_verif.name;

  Hashtbl.iter (fun valid_test (_,_) ->
    Process.initialise ();
    let lexbuf = Lexing.from_string valid_test in
    match (data_verif.parsing_function Testing_lexer.token lexbuf) Verify with
      | RLoad _ -> Config.internal_error "[testing_load_verify.ml >> verify_function] It should be a result for verify."
      | RVerify test when test <> valid_test ->

          let nb_fault = 1 + Hashtbl.length data_verif.data_IO.faulty_tests in

          (* Refresh HTML for orginal *)
          Process.initialise ();
          let lexbuf = Lexing.from_string valid_test in
          let valid_latex = match (data_verif.parsing_function Testing_lexer.token lexbuf) (Load (2*nb_fault)) with
            | RVerify _ -> Config.internal_error "[testing_load_verify.ml >> refresh_html] It should be a result for loading."
            | RLoad latex_test -> latex_test
          in

          (* Refresh HTML for new *)
          Process.initialise ();
          let lexbuf = Lexing.from_string test in
          let new_latex = match (data_verif.parsing_function Testing_lexer.token lexbuf) (Load (2*nb_fault + 1)) with
            | RVerify _ -> Config.internal_error "[testing_load_verify.ml >> refresh_html] It should be a result for loading."
            | RLoad latex_test -> latex_test
          in

          Hashtbl.add data_verif.data_IO.faulty_tests valid_test (valid_latex,test,new_latex,nb_fault)
      | _ -> ()
  ) data_verif.data_IO.validated_tests;

  let nb_of_faulty_tests = Hashtbl.length data_verif.data_IO.faulty_tests in

  if nb_of_faulty_tests = 0
  then Printf.printf ": All %d tests were successful\n" nb_of_tests
  else
    begin
      Printf.printf ": %d tests were successful but %d were unsuccessful. [WARNING]\n"  (nb_of_tests - nb_of_faulty_tests) nb_of_faulty_tests;
      publish_faulty_tests data_verif.data_IO
    end

(** [verify_all] verifies all the tests of all the functions. *)
let verify_all () = List.iter verify_tests all_data_verification

(** {3 Loading of tests} *)

let refresh_html_tests data_verif hash_tbl =
  Hashtbl.filter_map_inplace (fun terminal_test (_,id) ->
    Process.initialise ();
    let lexbuf = Lexing.from_string terminal_test in
    match (data_verif.parsing_function Testing_lexer.token lexbuf) (Load id) with
      | RVerify _ -> Config.internal_error "[testing_load_verify.ml >> refresh_html] It should be a result for loading."
      | RLoad latex_test -> Some (latex_test,id)
  ) hash_tbl

let refresh_html data_verif =
  refresh_html_tests data_verif data_verif.data_IO.validated_tests;
  refresh_html_tests data_verif data_verif.data_IO.tests_to_check

let load () =
  preload ();
  List.iter refresh_html all_data_verification

(** {3 Other publications} *)

let template_line_validated = "            <!-- Validated_tests -->"
let template_line_to_check = "            <!-- Tests_to_check -->"

let publish_index () =
  let path_html = Printf.sprintf "%stesting_data/testing.html" !Config.path_index
  and path_template = Printf.sprintf "%stesting.html" !Config.path_html_template in

  let out_html = open_out path_html in
  let open_template = open_in path_template in

  let print_validated_address data =
    Printf.fprintf out_html "<li>Function <a href=\"%svalidated_tests/%s.html\">%s</a> (Number of tests : %d)</li>"
      !Config.path_index
      data.data_IO.file
      data.name
      (Hashtbl.length data.data_IO.validated_tests)
  in

  let print_to_check_address data =
    Printf.fprintf out_html "<li>Function <a href=\"%stests_to_check/%s.html\">%s</a> (Number of tests : %d)</li>"
      !Config.path_index
      data.data_IO.file
      data.name
      (Hashtbl.length data.data_IO.tests_to_check)
  in

  let line = ref "" in
  while !line <> template_line_validated do
    let l = input_line open_template in
    if l <> template_line_validated
    then Printf.fprintf out_html "%s\n" l;
    line := l
  done;

  List.iter print_validated_address all_data_verification ;

  let l = input_line open_template in
  Printf.fprintf out_html "%s\n" l;
  line := l;

  while !line <> template_line_to_check do
    let l = input_line open_template in
    if l <> template_line_to_check
    then Printf.fprintf out_html "%s\n" l;
    line := l
  done;

  List.iter print_to_check_address all_data_verification ;

  try
    while true do
      let l = input_line open_template in
      Printf.fprintf out_html "%s\n" l;
    done
  with
    | End_of_file -> close_out out_html
