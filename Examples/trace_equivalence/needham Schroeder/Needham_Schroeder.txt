/*
Needham Schroeder Symmetric Key

Principal A,B,S

Key know by the principal :
K_as -> A, S
K_bs -> B ,S
K_ab fresh generated by S
*/

free A.
free B.
free I.
free bad.
free c.
free c_s.
free K_is.

fun senc/2.

reduc sdec(senc(x,y),y) -> x.

//   Description of principal S :

let processS(K_ab,K_as,K_bs) =

	in(c_s,w) ; let (x_a,x_b,x_n_a) = w in
	(
	if x_a = A then if x_b = B then out(c_s,senc((x_n_a,x_b,K_ab,senc((K_ab,x_a),K_bs)),K_as))
	|
	if x_a = I then if x_b = A then out(c_s, senc((x_n_a,x_b,K_ab,senc((K_ab,x_a),K_as)),K_is))
	|
	if x_a = I then if x_b = B then out(c_s, senc((x_n_a,x_b,K_ab,senc((K_ab,x_a),K_bs)),K_is))
	|
	if x_a = A then if x_b = I then out(c_s, senc((x_n_a,x_b,K_ab,senc((K_ab,x_a),K_bs)),K_is))
	).

//   Description of principal A :

let processA(K_as,i) =
  new N_a;
  out(c_s,(A,i,N_a));
  in(c_s,w);
  let (n_a,b,k_ab,cypher_b) = sdec(w,K_as) in
  if n_a = N_a then
	if b = i then
  out(c,cypher_b);
  in(c,z);
  out(c,senc(sdec(z,k_ab),k_ab)).

//   Description of principal B :

let processB_1(K_bs,K_ab) =
  in(c,w);
  let (k_ab,a)= sdec(w,K_bs) in
  if a = A
  then
    new N_b;
    out(c,senc(N_b,k_ab));
    in(c,t);
    if sdec(t,k_ab) = N_b
    then
      in(c,z);
      if z = N_b
      then
        out(bad,bad).


let processB_2(K_bs,K_ab) =
  in(c,w);
  let (k_ab,a)= sdec(w,K_bs) in
  if a = A
  then
    new N_b;
    out(c,senc(N_b,k_ab));
    in(c,t);
    if sdec(t,k_ab) = N_b
    then
      in(c,z).


//   Main

let P_1 =
  new K_as; new K_bs ; new K_ab ; (processS(K_ab,K_as,K_bs) | processA(K_as,I)  | processB_1(K_bs,K_ab)).

let P_2 =
  new K_as; new K_bs ; new K_ab ; (processS(K_ab,K_as,K_bs) | processA(K_as,I) | processB_2(K_bs,K_ab)).

query trace_equiv(P_1,P_2).
