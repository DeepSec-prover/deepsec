(* New version of Helios *)

free id1.
free id2.
free id3.

free c.

free replayedBallot.

free yes.
free no.

fun aenc/3.
fun pk/1.

reduc adec(xk, aenc(pk(xk), xr, xm)) -> xm.

(* The zero knowledge proof definition. *)

fun zkp/3.
fun zkpok/0.
reduc checkzkp(zkp(xr, xv, aenc(xpk, xr, xv)), aenc(xpk, xr, xv)) -> zkpok.

(* The set functions *)

fun cons/2.
reduc
  is_in_7(x,cons(cons(cons(cons(cons(cons(cons(x_empty,x),x2),x3),x4),x5),x6),x7)) -> x;
  is_in_7(x,cons(cons(cons(cons(cons(cons(cons(x_empty,x1),x),x3),x4),x5),x6),x7)) -> x;
  is_in_7(x,cons(cons(cons(cons(cons(cons(cons(x_empty,x1),x2),x),x4),x5),x6),x7)) -> x;
  is_in_7(x,cons(cons(cons(cons(cons(cons(cons(x_empty,x1),x2),x3),x),x5),x6),x7)) -> x;
  is_in_7(x,cons(cons(cons(cons(cons(cons(cons(x_empty,x1),x2),x3),x4),x),x6),x7)) -> x;
  is_in_7(x,cons(cons(cons(cons(cons(cons(cons(x_empty,x1),x2),x3),x4),x5),x),x7)) -> x;
  is_in_7(x,cons(cons(cons(cons(cons(cons(cons(x_empty,x1),x2),x3),x4),x5),x6),x)) -> x.

(* The natural number model *)

fun zero/0.
fun s/1.

(* The voting process *)

let V(auth,id,v,skE) =
    new r;
    out(auth, aenc(pk(skE), r, v));
    out(c, (id, aenc(pk(skE), r, v), zkp(r, v, aenc(pk(skE), r, v)))).

(* The Tally *)

let Outcome(prv_ch,skE,x1,x2) =
  in(prv_ch,z);
  let (vote1,vote2,vote3,check1,check2,nb_vote) = z in

  (* We check that we have 7 votes and that x1 and x2 are in check1 and check2 respectively. *)
  if nb_vote = s(s(s(s(s(s(s(zero))))))) then
  let z_test1 = is_in_7(x1,check1) in
  let z_test2 = is_in_7(x2,check1) in

  (* We check the replayed Ballot *)
  if vote1 = vote2
  then out(c,replayedBallot)
  else if vote1 = vote3
  then out(c,replayedBallot)
  else if vote2 = vote3
  then out(c,replayedBallot)
  else
    (* No replay so we output *)
    let xv1 = adec(skE,vote1) in
    let xv2 = adec(skE,vote2) in
    let xv3 = adec(skE,vote3) in
    (out(c,xv1) | out(c,xv2) | out(c,xv3)).

let VoteAssociation(prv_ch,vote1,vote2,vote3,check1,check2,nb_vote) =
  in(c, x);
  let (yid, yblob, yzkp) = x in
  if checkzkp(yzkp, yblob) = zkpok then
  if yid = id1
  then out(prv_ch,(yblob,vote2,vote3,cons(check1,yblob),cons(check1,zero),s(nb_vote)))
  else if yid = id2
  then out(prv_ch,(vote1,yblob,vote3,cons(check1,zero),cons(check1,yblob),s(nb_vote)))
  else if yid = id3
  then out(prv_ch,(vote1,vote2,yblob,cons(check1,zero),cons(check1,zero),s(nb_vote)))
  else 0.

let SubTally(prv_ch,x1,x2) =
  in(prv_ch,z);
  let (vote1,vote2,vote3,check1,check2,nb_vote) = z in

  (* We first check that there is enough ballot left for the voter to check correctly. *)
  if nb_vote = s(s(s(s(s(s(zero))))))  (* Test if nb_vote = 6 *)
  then
    let z_test1 = is_in_7(x1,check1) in (* Test if x1 is in the set check1 *)
      VoteAssociation(prv_ch,vote1,vote2,vote3,check1,check2,nb_vote)
    else
      let z_test2 = is_in_7(x2,check2) in (* Test if x1 is in the set check2 *)
        VoteAssociation(prv_ch,vote1,vote2,vote3,check1,check2,nb_vote)
      else 0
  else
    VoteAssociation(prv_ch,vote1,vote2,vote3,check1,check2,nb_vote).

let Tally(auth1,auth2,skE) =
  in(auth1,x1);
  in(auth2,x2);
  new prv_ch;
  (
    out(prv_ch,(zero,zero,zero,zero,zero,zero))
  | Outcome(prv_ch,skE,x1,x2)
  | !^7 SubTally(prv_ch,x1,x2)
  ).

let P =
  new auth1;
  new auth2;
  new auth3;
  new skE;
  out(c,pk(skE));
  (V(auth1,id1,yes,skE) | V(auth2,id2,no,skE) | Tally(auth1,auth2,skE)).

let Q =
  new auth1;
  new auth2;
  new auth3;
  new skE;
  out(c,pk(skE));
  (V(auth1,id1,no,skE) | V(auth2,id2,no,skE) | Tally(auth1,auth2,skE)).

query trace_equiv(P,Q).
