/* Denning Sacco symmetric key
  A -> S : A, B
  S -> A : {B, Kab, {Kab,A}Kbs }Kas
  A -> B : {Kab, A }Kbs


 Secrecy of the key Kab (from the point of view of A)
 encoded as a combination of key usability and “which key-concealing”
 A -> : {m1}Kab vs {m2}K with K fresh and m1/m2 public constants


 Scenario:
 one honest session between a, b, and s
 one instance of A played by a with c (dishonest)
 one intance of B played by b with c (dishonest)
two additional instances of S played with a/c and c/b
*/


free a.
free b.
free c.
free kcs.

free m1.
free m2.

free c1.
free c2.
free c3.
free c4.
free c5.
free c6.
free c7.

fun senc/2.
reduc sdec(senc(x,y),y) -> x.

let A1(ca,a,b,kas) =
 out(ca, (a,b));
 in(ca,xenc);
 let (x1,x2,x3) = sdec(xenc,kas) in
 if x1 =b then
 out(ca, x3);
 out(ca,senc(m1,x2)).

let A2(ca,a,b,kas) =
 out(ca, (a,b));
 in(ca,xenc);
 let (x1,x2,x3) = sdec(xenc,kas) in
 if x1 =b then
 out(ca, x3);
 new k;
 out(ca,senc(m2,k)).

let A(ca,a,b,kas) =
 out(ca, (a,b));
 in(ca,xenc);
 let (x1,x2,x3) = sdec(xenc,kas) in
 if x1 =b then
 out(ca, x3).

let S(cs,a,b,kas,kbs) =
 in(cs, y);
 let (y1,y2) = y in
 if (y1,y2) = (a,b) then
 new kab;
 out(cs, senc((b,kab,senc((kab,a),kbs)),kas)).


let B(cb,b,a,kbs) =
 in(cb,z);
 let (z1,z2) = sdec(z,kbs) in
 if z2 = a then 0.

let P =
 new kas; new kbs;
 ( A1(c1,a,b,kas) | S(c2,a,b,kas,kbs) | B(c3,b,a,kbs)
 | A(c4,a,c,kas) | S(c5,a,c,kas,kcs)| S(c6,c,b,kcs,kbs) |  B(c7,b,c,kbs)).


let Q =
 new kas; new kbs;
 ( A2(c1,a,b,kas) | S(c2,a,b,kas,kbs) | B(c3,b,a,kbs)
 | A(c4,a,c,kas) | S(c5,a,c,kas,kcs)| S(c6,c,b,kcs,kbs) |  B(c7,b,c,kbs)).

query trace_equiv(P,Q).
