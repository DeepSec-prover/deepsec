/*
  Needham-Schroeder symmetric key
  A -> S : A, B, Na
  S -> A : {B, Na, Kab, {A, Kab}Kbs }Kas
  A -> B : { A, Kab }Kbs
  B -> A : { Req, Nb }Kab
  A -> B : { Rep, Nb }Kab

 Secrecy of the key Kab (from the point of view of B)
 encoded as a combination of key usability and “which key-concealing”
 B -> : {m1}Kab vs {m2}K with K fresh and m1/m2 public constants

 Scenario: simple
 one session for each role, each played by an honest agent
*/

free a.
free b.

free m1.
free m2.
free req.
free rep.

free ca.
free cb.
free cs.

fun senc/2.
reduc sdec(senc(x,y),y) -> x.

let A(ca,a,b,kas) =
 new na;
 out(ca, (a,b,na));
 in(ca,xenc);
 let (x1,x2,x3,x4) = sdec(xenc,kas) in
 if (x1,x2) = (b,na) then
 out(ca, x4);
 in(ca,xchall);
 let (xreq,xnb) = sdec(xchall,x3) in
 out(ca,senc((rep,xnb),x3)).

let S(cs,a,b,kas,kbs) =
 in(cs, y);
 let (y1,y2,y3) = y in
 if (y1,y2) = (a,b) then
 new kab;
 out(cs, senc((b,y3,kab,senc((a,kab),kbs)),kas)).

let B1(cb,b,a,kbs) =
 in(cb,z);
 let (z2,z3) = sdec(z,kbs) in
 if z2 = a then
 new nb;
 out(cb,senc((req,nb),z3));
 in(cb,zchall);
 let (zrep,znb) = sdec(zchall,z3) in
 if (zrep,znb) = (rep,nb) then out(cb,senc(m1,z3)).

let B2(cb,b,a,kbs) =
 in(cb,z);
 let (z2,z3) = sdec(z,kbs) in
 if z2 = a then
 new nb;
 out(cb,senc((req,nb),z3));
 in(cb,zchall);
 let (zrep,znb) = sdec(zchall,z3) in
 new k;
 if (zrep,znb) = (rep,nb) then out(cb,senc(m2,k)).

let P =
 new kas; new kbs;
 ( A(ca,a,b,kas) | S(cs,a,b,kas,kbs) | B1(cb,b,a,kbs)).


let Q =
 new kas; new kbs;
 ( A(ca,a,b,kas) | S(cs,a,b,kas,kbs) | B2(cb,b,a,kbs)).

query trace_equiv(P,Q).
