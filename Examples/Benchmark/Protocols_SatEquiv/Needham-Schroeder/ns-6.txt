/*  Needham-Schroeder symmetric key
  A -> S : A, B, Na
  S -> A : {B, Na, Kab, {A, Kab}Kbs }Kas
  A -> B : { A, Kab }Kbs
  B -> A : { Req, Nb }Kab
  A -> B : { Rep, Nb }Kab

 Secrecy of the key Kab (from the point of view of B)
 encoded as a combination of key usability and “which key-concealing”
 B -> : {m1}Kab vs {m2}K with K fresh and m1/m2 public constants

 Scenario: double
 two sessions for each role, each played by the same honest agent
*/

free a.
free b.

free m1.
free m2.
free req.
free rep.

free c0.
free c1.
free c2.
free c3.
free c4.
free c5.

fun senc/2.
reduc sdec(senc(x,y),y) -> x.

let A(ca,a,b,kas) =
 in(ca,xinit);
 new na;
 out(ca, (a,b,na));
 in(ca,xenc);
 let (x1,x2,x3,x4) = sdec(xenc,kas) in
 if (x1,x2) = (b,na) then
 out(ca, x4);
 in(ca,xchall);
 let (xreq,xnb) = sdec(xchall,x3) in
 out(ca,senc((rep,xnb),x3)).

let S(cs,a,b,kas,kbs) =
 in(cs, y);
 let (y1,y2,y3) = y in
 if (y1,y2) = (a,b) then
 new kab;
 out(cs, senc((b,y3,kab,senc((a,kab),kbs)),kas)).


let B1(cb,b,a,kbs) =
 in(cb,z);
 let (z2,z3) = sdec(z,kbs) in
 if z2 = a then
 new nb;
 out(cb,senc((req,nb),z3));
 in(cb,zchall);
 let (zrep,znb) = sdec(zchall,z3) in
 if (zrep,znb) = (rep,nb) then out(cb,senc(m1,z3)).


let B2(cb,b,a,kbs) =
 in(cb,z);
 let (z2,z3) = sdec(z,kbs) in
 if z2 = a then
 new nb;
 out(cb,senc((req,nb),z3));
 in(cb,zchall);
 let (zrep,znb) = sdec(zchall,z3) in
 new k;
 if (zrep,znb) = (rep,nb) then out(cb,senc(m2,k)).


let B(cb,b,a,kbs) =
 in(cb,z);
 let (z2,z3) = sdec(z,kbs) in
 if z2 = a then
 new nb;
 out(cb,senc((req,nb),z3));
 in(cb,zchall);
 let (zrep,znb) = sdec(zchall,z3) in
 if (zrep,znb) = (rep,nb) then 0.

let P =
 new kas; new kbs; (
   A(c0,a,b,kas) | S(c1,a,b,kas,kbs) | B1(c2,b,a,kbs) |
   A(c3,a,b,kas) | S(c4,a,b,kas,kbs) | B(c5,b,a,kbs)
 ).

let Q =
 new kas; new kbs; (
   A(c0,a,b,kas) | S(c1,a,b,kas,kbs) | B2(c2,b,a,kbs) |
   A(c3,a,b,kas) | S(c4,a,b,kas,kbs) | B(c5,b,a,kbs)
 ).

query trace_equiv(P,Q).
