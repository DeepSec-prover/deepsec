/*
Wide Mouthed Frog protocol (without timestamps)
A -> S: A, {B,Kab}Kas
S -> B: {A,Kab}Kbs


Secrecy of the key Kab (from the point of view of B)
encoded as a combination of key usability and “which key-concealing”
B -> : {m1}Kab vs {m2}K with K fresh and m1/m2 public constants

Scenario:
one honest session between a, b, and s
one instance of A played by a with c (dishonest)
one intance of B played by b with c (dishonest)
two additional instances of S played with a/c and c/b
*/

free a.
free b.
free c.
free m1.
free m2.
free kcs.
free c0.
free c1.
free c2.
free c3.
free c4.
free c5.
free c6.

fun senc/2.
reduc sdec(senc(x,y),y) -> x.

let A(ca,a,b,kas) =
  new kab;
  out(ca, (a, senc((b,kab),kas))).

let S(cs,a,b,kas,kbs) =
  in(cs, x);
  let (xa,xenc) = x in
  if xa = a then
  let (xb,xk) = sdec(xenc,kas) in
  if xb = b
  then out(cs, senc((a,xk),kbs)).


let B(cb,b,a,kbs) =
  in(cb,y);
  let (ya,yk) = sdec(y,kbs) in 0.

let B1(cb,b,a,kbs) =
  in(cb,y);
  let (ya,yk) = sdec(y,kbs) in
  if ya = a then out(cb,senc(m1,yk)).

let B2(cb,b,a,kbs) =
  in(cb,y);
  let (ya,yk) = sdec(y,kbs) in
  if ya = a then new k; out(cb,senc(m2,k)).


let P =
  new kas; new kbs; (
    A(c0,a,b,kas) | S(c1,a,b,kas,kbs) | B1(c2,b,a,kbs) |
    A(c3,a,c,kas) | S(c4,a,c,kas,kcs) |
    S(c5,c,b,kcs,kbs) | B(c6,c,b,kbs)
  ).

let Q =
  new kas; new kbs; (
    A(c0,a,b,kas) | S(c1,a,b,kas,kbs) | B2(c2,b,a,kbs) |
    A(c3,a,c,kas) | S(c4,a,c,kas,kcs) |
    S(c5,c,b,kcs,kbs) | B(c6,c,b,kbs)
  ).

query trace_equiv(P,Q).
