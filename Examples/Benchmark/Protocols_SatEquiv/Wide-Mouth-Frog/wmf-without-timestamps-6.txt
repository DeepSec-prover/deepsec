/*
Wide Mouthed Frog protocol (without timestamps)
A -> S: A, {B,Kab}Kas
S -> B: {A,Kab}Kbs


Secrecy of the key Kab (from the point of view of B)
encoded as a combination of key usability and “which key-concealing”
B -> : {m1}Kab vs {m2}K with K fresh and m1/m2 public constants


Scenario: double
two sessions for each role, each played by the same honest agent

*/



// WMF POUR APTE
free a.
free b.
free m1.
free m2.
free ca1.
free cb1.
free cs1.
free ca2.
free cb2.
free cs2.

fun senc/2.
reduc sdec(senc(x,y),y) -> x.

let A(ca,a,b,kas) =
  new kab;
  in(ca,z);
  out(ca, (a, senc((b,kab),kas))).

let S(cs,a,b,kas,kbs) =
  in(cs, x);
  let (xa,xenc) = x in
  if xa = a then
  let (xb,xk) = sdec(xenc,kas) in
  if xb = b
  then out(cs, senc((a,xk),kbs)).

let B(cb,b,a,kbs) =
  in(cb,y);
  let (ya,yk) = sdec(y,kbs) in 0.

let B1(cb,b,a,kbs) =
  in(cb,y);
  let (ya,yk) = sdec(y,kbs) in
  if ya = a then out(cb,senc(m1,yk)).

let B2(cb,b,a,kbs) =
  in(cb,y);
  let (ya,yk) = sdec(y,kbs) in
  if ya = a then new k; out(cb,senc(m2,k)).


let P =
  new kas; new kbs; (
    A(ca1,a,b,kas) | S(cs1,a,b,kas,kbs) | B1(cb1,b,a,kbs) |
    A(ca2,a,b,kas) | S(cs2,a,b,kas,kbs) | B(cb2,b,a,kbs)
  ).


let Q =
  new kas; new kbs; (
    A(ca1,a,b,kas) | S(cs1,a,b,kas,kbs) | B2(cb1,b,a,kbs) |
    A(ca2,a,b,kas) | S(cs2,a,b,kas,kbs) | B(cb2,b,a,kbs)
  ).


query trace_equiv(P,Q).
