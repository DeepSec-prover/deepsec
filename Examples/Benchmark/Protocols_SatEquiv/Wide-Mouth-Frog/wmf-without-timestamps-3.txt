/* Wide Mouthed Frog protocol (without timestamps)
 A -> S: A, {B,Kab}Kas
 S -> B: {A,Kab}Kbs


 Secrecy of the key Kab (from the point of view of B)
 encoded as a combination of key usability and “which key-concealing”
 B -> : {m1}Kab vs {m2}K with K fresh and m1/m2 public constants


 Scenario: simple
 one session for each role, each played by an honest agent

*/


// WMF POUR APTE
free a.
free b.
free m1.
free m2.
free ca.
free cb.
free cs.

fun senc/2.
reduc sdec(senc(x,y),y) -> x.

let A(ca,a,b,kas) =
  new kab;
  in(ca,z);
  out(ca, (a, senc((b,kab),kas))).

let S(cs,a,b,kas,kbs) =
  in(cs, x);
  let (xa,xenc) = x in
  if xa = a then
  let (xb,xk) = sdec(xenc,kas) in
  if xb = b
  then out(cs, senc((a,xk),kbs)).

let B1(cb,b,a,kbs) =
  in(cb,y);
  let (ya,yk) = sdec(y,kbs) in
  if ya = a then out(cb,senc(m1,yk)).

let B2(cb,b,a,kbs) =
  in(cb,y);
  let (ya,yk) = sdec(y,kbs) in
  if ya = a then new k; out(cb,senc(m2,k)).


let P =
  new kas; new kbs; (
    A(ca,a,b,kas) | S(cs,a,b,kas,kbs) | B1(cb,b,a,kbs)
  ).


let Q =
  new kas; new kbs; (
    A(ca,a,b,kas) | S(cs,a,b,kas,kbs) | B2(cb,b,a,kbs)
  ).


query trace_equiv(P,Q).
