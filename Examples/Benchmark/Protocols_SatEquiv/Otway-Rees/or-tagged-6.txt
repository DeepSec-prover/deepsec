/*
Otway Rees symmetric key
  A -> B : M,A,B,{1,Na,M,A,B}Kas
  B -> S : M,A,B,{1,Na,M,A,B}Kas,{2,Nb,M,A,B}Kbs
  S -> B : M, {3,Na,Kab}Kas, {4,Nb,Kab}Kbs
  B -> A : M,{3,Na,Kab}Kas

Secrecy of the key Kab (from the point of view of B)
encoded as a combination of key usability and “which key-concealing”
B -> : {m1}Kab vs {m2}K with K fresh and m1/m2 public constants

Scenario: simple
one session for each role, each played by an honest agent

*/

//Channels :
free ca1.
free cb1.
free cs1.
free ca2.
free cb2.
free cs2.

//Constants:
free c1.
free c2.
free c3.
free c4.
free m1.
free m2.
free a.
free b.
free ok.

fun senc/2.
reduc sdec(senc(x,y),y) -> x.

let A(ca,a,b,kas) =
  new m ;
  new na ;
  out(ca,(m,a,b,senc((c1,na,m,a,b),kas)));
  in(ca,x0);
  let (xmm,xsenc) = x0 in
  let (xc3,xna,xkab) = sdec(xsenc,kas) in
  if (xmm,xc3,xna) = (m,c3,na) then
  0.

let BP(cb,b,a,kbs) =
  in(cb,yinit);
  let (ym,ya,yb,yza1) = yinit in
  if (ya,yb) = (a,b) then
  new nb ;
  out(cb,(ym,a,b,yza1,senc((c2,nb,ym,a,b),kbs)));
  in(cb,y1);
  let (ymm,yza2,y2) = y1 in
  let (yc4,ynb,ykab) = sdec(y2,kbs) in
  if (ymm,yc4,ynb) = (ym,c4,nb) then
  out(cb,(ym,yza2));
  out(cb,senc(m1,ykab)).

let BQ(cb,b,a,kbs) =
  in(cb,yinit);
  let (ym,ya,yb,yza1) = yinit in
  if (ya,yb) = (a,b) then
  new nb ;
  out(cb,(ym,a,b,yza1,senc((c2,nb,ym,a,b),kbs)));
  in(cb,y1);
  let (ymm,yza2,y2) = y1 in
  let (yc4,ynb,ykab) = sdec(y2,kbs) in
  if (ymm,yc4,ynb) = (ym,c4,nb) then
  out(cb,(ym,yza2));
  new k;
  out(cb,senc(m2,k)).

let B(cb,b,a,kbs) =
  in(cb,yinit);
  let (ym,ya,yb,yza1) = yinit in
  if (ya,yb) = (a,b) then
  new nb ;
  out(cb,(ym,a,b,yza1,senc((c2,nb,ym,a,b),kbs)));
  in(cb,y1);
  let (ymm,yza2,y2) = y1 in
  let (yc4,ynb,ykab) = sdec(y2,kbs) in
  if (ymm,yc4,ynb) = (ym,c4,nb) then
  out(cb,(ym,yza2)).


let S(cs,a,b,kas,kbs) =
  in(cs,z0);
  let (zm,za,zb,zsenc1,zsenc2) = z0 in
  let (zc1,zna,zmm,zaa,zbb) = sdec(zsenc1,kas) in
  let (zc2,znb,zmmm,zaaa,zbbb)= sdec(zsenc2,kbs) in
  if (zmm,zmmm,za,zaa,zaaa,zb,zbb,zbbb,zc1,zc2) = (zm,zm,a,a,a,b,b,b,c1,c2) then
  new kab;
  out(cs,(zm,senc((c3,zna,kab),kas),senc((c4,znb,kab),kbs))).

let P =
  new kas; new kbs ; (
    A(ca1,a,b,kas) | S(cs1,a,b,kas,kbs) | BP(cb1,b,a,kbs) |
    A(ca2,a,b,kas) | S(cs2,a,b,kas,kbs) | B(cb2,b,a,kbs)
  ).

let Q =
  new kas; new kbs ; (
    A(ca1,a,b,kas) | S(cs1,a,b,kas,kbs) | BQ(cb1,b,a,kbs) |
    A(ca2,a,b,kas) | S(cs2,a,b,kas,kbs) | B(cb2,b,a,kbs)
  ).

query trace_equiv(P,Q).
