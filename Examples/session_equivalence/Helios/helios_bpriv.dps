free alice, bob, attacker. // identities

free c. // public channel
free auth,internal [private]. // private channels

// encryption
fun aenc/3.
fun pk/1.
const decryption_key [private].
reduc adec(aenc(x,r,pk(sk)),sk) -> x.

// zero knowledge proofs
fun zkp/4.
fun zkpok/0.
reduc checkzkp(zkp(xr, xid, xv, aenc(xv,xr,xpk)), xid, aenc(xv,xr,xpk)) -> zkpok.

const zero. // blank vote

// voting process
let VoterReal(id,pkE) =
  in(c,v); // receives voting instructions from the attacker
  let (v0,v1) = v in
  new r0;
  let b0 = aenc(v0,r0,pkE) in
  let zk0 = zkp(r0,id,v0,b0) in
  out(c, (id,(b0,zk0))); // gives the real vote to the attacker
  out(auth, (id,(b0,zk0))). // cast their vote

let VoterFake(id,pkE) =
  in(c,v); // receives voting instructions from the attacker
  let (v0,v1) = v in
  new r0; new r1;
  let b0 = aenc(v0,r0,pkE) in
  let zk0 = zkp(r0,id,v0,b0) in
  let b1 = aenc(v1,r1,pkE) in
  let zk1 = zkp(r1,id,v1,b1) in
  out(c, (id,(b1,zk1))); // gives the fake vote to the attacker
  out(auth, (id,(b0,zk0))). // cast their vote


// Tallying
let SubTally =
  in(internal,z);
  let (vote1,vote2,vote3) = z in // gets internal state

  in(c,id). // voting instructions from the attacker
  if id = attacker then
    in(vote);
    let (blob,zk) = vote in
    if checkzkp(zk,attacker,blob) = zkpok then out(internal,(vote1,vote2,blob))
    else out(internal,(vote1,vote2,vote3))
  else
    in(auth,vote); // receives honest vote
    let (=id,(blob,zk)) = vote in
      if checkzkp(zk,id,blob) = zkpok then
        if id = alice then out(internal,(blob,vote2,vote3))
        else if id = bob then out(internal,(vote1,blob,vote3))
        else out(internal,(vote1,vote2,vote3))
      else out(internal,(vote1,vote2,vote3))
    else out(internal,(vote1,vote2,vote3)).


// getting the result of the subtallies and outputing in a mixnet
let Mixnet =
  in(internal,z);
  let (vote1,vote2,vote3) = z in (
    out(c,adec(vote1,decryption_key)) |
    out(c,adec(vote2,decryption_key)) |
    out(c,adec(vote3,decryption_key)) (* The decryption of the ballot of id3 is done at the lvl of the output allowing the attacker NOT to vote. *)
  ).


// overall tally
let Tally =
  out(internal,(zero,zero,zero)) |
  !^7 SubTally |
  Mixnet.


// process under equivalence
let VotingSystemReal =
  let pkE = pk(decryption_key) in
  out(c,pkE); (
    !^2 VoterReal(alice,pkE) |
    !^2 VoterReal(bob,pkE) |
    Tally
  ).

let VotingSystemFake =
  let pkE = pk(decryption_key) in
  out(c,pkE); (
    !^2 VoterFake(alice,pkE) |
    !^2 VoterFake(bob,pkE) |
    Tally
  ).

query session_equiv(VotingSystemReal,VotingSystemFake).
