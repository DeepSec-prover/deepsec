free c. /* communication channel */
free reveal. /* channel to reveal information to the environment/attacker */
free secure_channel [private]. /* a secure channel between mixer and board */
free login_channel [private]. /* a secure channel to transmit signature keys */

const yes,no. /* potential votes */

fun pk/1. /* public key generation */
fun enc/3. /* randomized assymetric encryption */
reduc dec(enc(x,pk(y),z),y) -> x. /* decryption */
fun sign/2. /* signatures */
reduc verify(sign(m,y),pk(y)) -> m. /* check signatures */

const sk_enc [private]. /* encryption key */




/* a voter voting for v with public key pk */
let honnest_voter(v) =
  new sk_sign;
  let pk_sign = pk(sk_sign) in
  new r;
  let v_enc = enc((v,pk_sign),pk(sk_enc),r) in
  out(login_channel,pk_sign);
  out(reveal,pk_sign);
  out(c,sign(v_enc,sk_sign)).

/* a dishonnest voter that reveals its signature key */
let dishonnest_voter =
  new sk_sign;
  out(login_channel,pk(sk_sign));
  out(reveal,sk_sign).

/* mixnet */
let mixer =
  /* receiving signature keys and signed votes */
  in(login_channel,pk_sign);
  in(c,x);
  let (v,=pk_sign) = verify(x,pk_sign) in
  out(c,v).

/* bulletin board receiving and publishing the votes */
let board =
  /* receiving the mixed votes */
  in(secure_channel,x1);
  in(secure_channel,x2);
  in(secure_channel,x3);
  in(secure_channel,x4);
  /* decrypting the votes (fails if they are not encryptions) */
  let (id1,v1) = dec(x1,sk_enc) in
  let (id2,v2) = dec(x2,sk_enc) in
  let (id3,v3) = dec(x3,sk_enc) in
  let (id4,v4) = dec(x4,sk_enc) in
  out(reveal,(v1,v2,v3,v4)).


/* the voting system */
let system(v1,v2) =
  out(c,pk(sk_enc)); (
    honnest_voter(v1) |
    honnest_voter(v2) |
    !^2 dishonnest_voter |
    !^4 mixer
  ).



/* vote privacy for 4 honnest voters and 2 dishonnest voter */
query session_equiv(system(yes,no),system(no,yes)).
