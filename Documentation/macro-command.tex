%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Manual  Counter that can be referenced
%%%%%%%%%%%%%%%%%%%%%%%%%%


\newcounter{counterEnumerate}
\newcommand{\enumreset}{\setcounter{counterEnumerate}{0}}
\newcommand{\enumitem}[1]{{\refstepcounter{counterEnumerate}\label{#1}
  \thecounterEnumerate. }}
\newcommand{\hateq}{\mathrel{\hat{=}}}

\newcommand{\eqdef}{\mathbin{\overset{\mathrm{def}}{=}}}

\makeatletter
\DeclareRobustCommand{\bigplus}{%
  \mathop{\vphantom{\sum}\mathpalette\@bigplus\relax}\slimits@
}
\newcommand{\@bigplus}[2]{\vcenter{\hbox{\make@bigplus{#1}}}}
\newcommand{\make@bigplus}[1]{%
  \sbox\z@{$\m@th#1\sum$}%
  \setlength{\unitlength}{\wd\z@}%
  \begin{picture}(1.4,1.4)
  %\roundcap
  \linethickness{.17ex}
  \Line(.7,.14)(.7,1.26)
  \Line(.14,.7)(1.26,.7)
  \end{picture}%
}
\makeatother



\RequirePackage{mdframed}
\newmdenv[
  leftmargin = 3pt,
  innerleftmargin = 8pt,
  innertopmargin = 0pt,
  innerbottommargin = 0pt,
  innerrightmargin = 0pt,
  rightmargin = 0pt,
  linewidth = 0.6pt,
  topline = false,
  rightline = false,
  bottomline = false,
  linecolor=lightgray
  ]{leftbar}


%%
%%% MODIFICATION OF THE PROOF ENVIRONEMENT (COMMENT TO GET BACK TO USUAL)
%%

\makeatletter
\renewenvironment{proof}[1][\proofname]{\begin{leftbar}\par
  \pushQED{\qed}%
  \normalfont \topsep6\p@\@plus6\p@\relax
  \trivlist
  \item[%
    \hskip\labelsep
    \normalfont\itshape % was \itshape
    #1%
    \@addpunct{.}% remove this if you don't want punctuation
  ]\ignorespaces
}{%
  \popQED\endtrivlist\@endpefalse
  \end{leftbar}
}
\let\qed\relax % avoid a warning
\DeclareRobustCommand{\qed}{%
  \ifmmode \mathqed
  \else
    \leavevmode\unskip\penalty\@M\hbox{}\nobreak\hfill% was \hfill
    \hbox{\qedsymbol}%
  \fi
}
\makeatother





%%
%%% Verification tools
%%

\newcommand{\spec}{{\sf SPEC}\xspace}
\newcommand{\apte}{{\sf APTE}\xspace}
\newcommand{\akiss}{{\sf AKISS}\xspace}
\newcommand{\proverif}{ProVerif\xspace}
\newcommand{\tamarin}{Tamarin\xspace}

%%
%%% Multiset
%%

\newcommand{\p}{\mathcal{P}}                    % Standard multiset : P
\newcommand{\q}{\mathcal{Q}}                    % Standard multiset : Q

\newcommand{\lmulti}{\{\!\!\{}                  % Adaptive left multiset
\newcommand{\rmulti}{\}\!\!\}}                  % Adaptive right multiset

\newcommand{\Lmulti}{\left\{\!\!\left\{}        % Adaptive left multiset
\newcommand{\Rmulti}{\right\}\!\!\right\}}      % Adaptive right multiset

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Term algebra
%%%%%%%%%%%%%%%%%%%%%%%%%%

%%
%%% Sets
%%

\newcommand{\N}{\mathcal{N}}                    % Set of names
\newcommand{\M}{\mathcal{M}}                    % Measures
\newcommand{\Npub}{\mathcal{N}_{\mathsf{pub}}}  % Set of public names
\newcommand{\Npriv}{\mathcal{N}_{\mathsf{prv}}} % Set of private names
\newcommand{\X}{\mathcal{X}}                    % Set of variables
\newcommand{\Xun}{\mathcal{X}^1}                % Set of first-order variables
\newcommand{\Xdeux}{\mathcal{X}^2}              % Set of second-order variables
\newcommand{\Xdeuxi}[1]{\mathcal{X}^2_{:#1}}    % Set of second-order variables

\newcommand{\Tun}{\T^1}                 	     % Set of first-order terms
\newcommand{\Tdeux}{\T^2}              	     % Set of second-order terms without public names

\newcommand{\AX}{\mathcal{AX}}                  % Set of axioms

\newcommand{\F}{\mathcal{F}}                    % Signature of function symbols
\newcommand{\Fc}{\mathcal{F}_c}                 % Set of constructors
\newcommand{\Fd}{\mathcal{F}_d}                 % Set of destructors

\newcommand{\Ec}{\mathcal{E}}                   % Set of private names

\newcommand{\A}{\mathcal{A}}                    % Alphabet of semantics

\newcommand{\Set}{{\sf S}}                      % Standard set S
\newcommand{\SetR}{{\sf R}}                     % Standard set R

%%
%%% Function symbols
%%

\newcommand{\ax}{\mathsf{ax}}                   % An axiom

\newcommand{\ffun}{\mathsf{f}}                  % Standard function : f
\newcommand{\gfun}{\mathsf{g}}                  % Standard function : g
\newcommand{\hfun}{\mathsf{h}}                  % Standard function : h

\newcommand{\pair}[2]{\langle#1,#2\rangle}      % Paring
\newcommand{\projun}{\mathsf{proj}_1}           % First projection of pairing
\newcommand{\projdeux}{\mathsf{proj}_2}         % Second projection of pairing
\newcommand{\senc}{\mathsf{senc}}               % Symmetric encryption
\newcommand{\sdec}{\mathsf{sdec}}               % Symmetric decryption
\newcommand{\aenc}{\mathsf{aenc}}               % Asymmetric encryption
\newcommand{\renc}{\mathsf{renc}}               % Re-encryptable encryption
\newcommand{\adec}{\mathsf{adec}}               % Asymmetric decryption
\newcommand{\rencrypt}{\mathsf{rencrypt}}       % Re-encryption proces
\newcommand{\pk}{\mathsf{pk}}                   % Public key
\newcommand{\h}{\mathsf{h}}                     % Hash function

%%
%%% Terms
%%

\newcommand{\T}{\mathcal{T}}                    % Terms definition

\newcommand{\st}[1]{\mathit{st}(#1)}            % Subterms of a term or recipe
\newcommand{\sst}[1]{\mathit{sst}(#1)}          % Strict Subterms of a term or recipe

\newcommand{\stun}[1]{\mathit{st}^1(#1)}        % First-order subterms of an element
\newcommand{\stdeux}[1]{\mathit{st}^2(#1)}      % Second-order subterms of an element

\newcommand{\sstdeux}[1]{\mathit{sst}^2(#1)}    % Second-order strict Subterms of a term or recipe

\newcommand{\rootsymb}[1]{\mathit{root}(#1)}    % Root symbol of a term.

\newcommand{\vars}[1]{\mathit{vars}(#1)}        % Free variables
\newcommand{\varsun}[1]{\mathit{vars}^1(#1)}    % Free first-order variables
\newcommand{\varsdeux}[1]{\mathit{vars}^2(#1)}  % Free second-order variables

\newcommand{\bvars}[1]{\mathit{bvars}(#1)}      % Bound variables
\newcommand{\bvarsun}[1]{\mathit{bvars}^1(#1)}  % Bound first-order variables
\newcommand{\bvarsdeux}[1]{\mathit{bvars}^2(#1)}% Bound second-order variables

\newcommand{\axioms}[1]{\mathit{axioms}(#1)}    % Axioms of a recipe
\newcommand{\names}[1]{\mathit{names}(#1)}      % Names of a term


\newcommand{\replacepos}[3]{#1[#3]_{#2}}        % Replace in #1 at position #2  by the term #3
\newcommand{\getpos}[2]{#1|_{#2}}               % Get the term in #1 at position #2

\newcommand{\Pos}[1]{\mathcal{P}(#1)}

\newcommand{\predmsg}[1]{\mathit{Msg}(#1)}      % Predicate message

\newcommand{\Dom}[1]{\mathit{dom}(#1)}          % Domain of a substitution
\newcommand{\Img}[1]{\mathit{img}(#1)}          % Image of a substitution
\newcommand{\SubRestr}[2]{#1|_{#2}}             % Restriction of a substitution to a domain
\newcommand{\Extends}[2]{{#1} \succeq  {#2}}             % Substitution #1 extends substitution #2

\newcommand{\mgu}[2]{\mathit{mgu}(#1,#2)}       % Most general unifier
\newcommand{\mguset}[1]{\mathit{mgu}(#1)}       % Most general unifier on a set of pair of terms.

\newcommand{\refer}{\mapsto}                    % Reference of an axiom to a term

%%
%%% Rewriting system and equational theory
%%

\newcommand{\R}{\mathcal{R}}                    % Rewriting system
\newcommand{\norm}{\mathord\downarrow}          % Normalisation

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Processes
%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\process}[2]{(#1,#2)}               % Extended process

\newcommand{\IfP}{\mathop{\texttt{if}}}         % Conditional If
\newcommand{\ElseP}{\mathop{\texttt{else}}}     % Conditional Then
\newcommand{\ThenP}{\mathop{\texttt{then}}}     % Conditional Else
\newcommand{\OutP}[2]{\overline{#1}\langle #2 \rangle}    % Outputs
\newcommand{\InP}[2]{#1(#2)}                    % Inputs

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Semantics
%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\cstep}[2][]{\xrightarrow{#2}^{#1}_{\sf c}}      % One step in the concrete semantics
\newcommand{\Cstep}[1]{\xRightarrow{#1}_{\sf c}}      % Multiple steps in the concrete semantics

\newcommand{\sstep}[1]{\xrightarrow{#1}_{\sf s}}      % One step in the symbolic semantics
\newcommand{\Sstep}[1]{\xRightarrow{#1}_{\sf s}}      % Multiple steps in the symbolic semantics

\newcommand{\tr}{\mathsf{tr}}                   % Standard trace labels

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Equivalences
%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\StatEq}{\sim}                      % Static equivalence

\newcommand{\TraceEqSub}{\sqsubseteq_t}         % Trace inclusion
\newcommand{\TraceEq}{\approx_t}                % Trace equivalence

\newcommand{\ObsEq}{\approx_o}                  % Observational equivalence
%\newcommand{\Rel}{\mathbin{\scriptstyle \Re}}
%\newcommand{\notRel}{\centernot{\Rel}}
\newcommand{\Rel}[1][T]{\approx^{\sf PT}_T}
\newcommand{\notRel}[1][T]{\not\Rel[#1]}

\newcommand{\subsymb}{\sqsubseteq}              % Symbolic inclusion
\newcommand{\symbeq}{\approx}                   % Symbolic equivalence

\newcommand{\esymbeq}{\approx}

\newcommand{\EQP}[2][]{\mathsf{Equiv}_{#1}^{#2}}




%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Encoding tools
%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\sem}[1]{\left\llbracket #1 \right\rrbracket}
\newcommand{\eint}[2]{\llbracket #1,#2\rrbracket}

\newcommand{\evalFormula}[2]{#1 \leftarrow #2}
\newcommand{\guessBinary}[1]{\mathsf{Guess}(#1)}

\newcommand{\qsat}[1]{{\sc qsat}$_#1$}
\newcommand{\qbf}{{\sc qbf}\xspace}

\newcommand{\D}{\mathcal{D}}                    % Complexity class
\newcommand{\polyh}[1]{\Pi_{#1}}                % Polynomial hierarchy

\newcommand{\0}{\mathsf{0}}
\newcommand{\1}{\mathsf{1}}
\newcommand{\val}{{\tt val}}

\newcommand{\TestNode}{\mathsf{TestNode}}
\newcommand{\TestBool}{\mathsf{TestBool}}

\newcommand{\Node}{{\tt Node}}

\newcommand{\gNode}{\gfun_{\mathsf{N}}}
\newcommand{\gBool}{\gfun_{\mathbb{B}}}

\newcommand{\Bad}{{\tt bad}}

\newcommand{\args}[2]{\overrightarrow{#1}^{#2}}


%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Symbolic calculus
%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\csys}[3]{(#1,#2,#3)}               % Constraint system
\newcommand{\ecsys}[7]{(#1,#2,#3,#4,#5,#6,#7)}  % Extended constraint system

%\newcommand{\conf}[2]{(#1,#2)}

\newcommand{\As}{\mathcal{A}_{\sf s}}                  % Alphabet of symbolic semantics

\newcommand{\C}{\mathcal{C}}                    % Standard constraint system
\newcommand{\V}{\mathcal{V}}                    % Standard vector of constraint systems

\newcommand{\Df}{\mathsf{D}}                    % Set of deduction facts

\newcommand{\dedfact}[2]{#1 \vdash^? #2}   % A deduction fact
\newcommand{\eqfact}[2]{#1 \eqf #2}	             % An equality fact

\newcommand{\equality}[1]{#1|_=}                % Restriction to equations
\newcommand{\disequality}[1]{#1|_{\neq}}        % Restriction to disequation

\newcommand{\clause}[3]{\forall #1.#2 \Leftarrow #3}     % Clause

\newcommand{\Fmgu}[1]{\alpha[#1]}
\newcommand{\Nmgu}[1]{mgu(#1)}

\newcommand{\Equn}{{\sf E}^1}                   % First order (dis)equations
\newcommand{\Eqdeux}{{\sf E}^2}				     % Second order (dis)equations

\newcommand{\Solved}{{\sf SDF}}                 % Set of solved deduction facts
\newcommand{\USolved}{{\sf UF}}                 % Set of unsolved facts

\newcommand{\SetRestr}[2]{{#1|_{\Tdeux_{#2}}}}  % Restriction of a set of facts
\newcommand{\CRestr}[2]{{#1|_{\Tdeux_{#2}}}}  % Restriction of a set of facts
\newcommand{\FRestr}[2]{{#1|^{#2}}}  % Restriction of a set of facts
\newcommand{\DRestr}[2]{{#1|^{#2}}}  % Restriction of a set of disequation to a constraint system.

\newcommand{\InitInput}{{\sf R}}

\newcommand{\eqi}{=^?_\R}                  % Equation modulo rewriting system
\newcommand{\neqi}{\neq^?_\R}                 % Disequation modulo rewriting system
\newcommand{\eqs}{=^?}                          % Syntactic equation
\newcommand{\neqs}{\neq^?}                      % Syntactic disequation
\newcommand{\eqf}{=^?_f}                        % Equation w.r.t. frame
\newcommand{\neqf}{\neq^?_f}                    % Disequation w.r.t. frame
\newcommand{\Unif}[2]{\mathcal{U}(#1, #2)}            % Uniformity

\newcommand{\receq}{\simeq_{\sf r}}             % Recipe equivalent

\newcommand{\quanti}[2]{#1\text{:}#2}		     % Quantified variable

\newcommand{\Sol}[2][{}]{\mathit{Sol}{^{#1}}(#2)}          % Solutions of a constraint system
\newcommand{\Sole}[1]{\mathit{Sol}_e(#1)}       % Solutions of an extended constraint system

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Partition tree
%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\FunctionSol}{\mathsf{sol}}
\newcommand{\ProcedurePartitionTree}{{\tt PartitionTree}\xspace}
\newcommand{\PTS}[2]{{\tt PTS}_{#1,#2}\xspace}

\newcommand{\tstep}[2]{\xrightarrow{#1}_{#2}}      % One step in the partition tree
\newcommand{\Tstep}[2]{\xRightarrow{#1}_{#2}}      % Multiple steps in the partition tree

\newcommand{\PartitionTree}[2]{\mathsf{PTree}(#1,#2)}

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Most general solutions
%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\mgs}[1]{mgs(#1)}                   % Most general solutions
\newcommand{\MgsStep}[1]{\mathrel{{\xrightarrow{\Sigma}}\Vnorm}}
\newcommand{\aritymax}{\mathsf{ar}_{max}}


%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Termination
%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\NotDeducedTerms}[1]{\mathsf{NDedT}(#1)}

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Algorithm
%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\transform}{{\mathrm T}}

%%% Guess predicates

\newcommand{\Skel}[2]{\mathsf{Skel}(#1,#2)}             % Skeleton of the left hand side of a rewrite rule

\newcommand{\RewF}[3]{\mathsf{RewF}(#1,#2,#3)}
\newcommand{\EqF}[2]{\mathsf{EqF}(#1,#2)}

\newcommand{\psiEq}[2]{\psi^{eq}_{X,Y}}

\newcommand{\FApply}[3]{#2\text{:}(#1,#3)}
\newcommand{\CApply}[2]{#2\text{:}#1}

\newcommand{\maxaxioms}[2]{\mathsf{max\_ax}(#1,#2)}        % Maximum axioms

%%% Emptiness predicate

\newcommand{\EmptyCsys}[1]{\Sol{#1} \eqs \emptyset}		% Emptiness predicate

%%% Rules

\newcommand{\Rule}{\textsc{Rule}}
\newcommand{\Satisfiable}{\textsc{Sat}}
\newcommand{\Fact}{\textsc{Res}}
\newcommand{\Rew}{\textsc{Rew}}
\newcommand{\Conseq}{\textsc{Conseq}}
\newcommand{\Solve}{\textsc{Solve}}
\newcommand{\Equality}{\textsc{Equality}}
\newcommand{\EqCons}{\textsc{Eq-Cons}}
\newcommand{\Consequence}[1]{\textsc{Conseq}(#1)}
\newcommand{\CompatibleSubs}[1]{\textsc{CompSub}(#1)}

\newcommand{\DCons}{\textsc{F-Cons}}
\newcommand{\DFact}{\textsc{F-Res}}
\newcommand{\DRew}{\textsc{F-Rew}}
\newcommand{\DConseq}{\textsc{F-Conseq}}

\newcommand{\UCons}{\textsc{U-Cons}}
\newcommand{\UFact}{\textsc{U-Res}}
\newcommand{\UConseq}{\textsc{U-Conseq}}

%%% Graphic

\newcommand{\splitone}[3]{
\noindent\begin{tikzpicture}[
rect/.style={
	rectangle
}]
\node (Title) [rect,anchor=west] at (0,0.8) {$#1$};
\node (Father) [rect,anchor=west] at (0,0) {$#2$};
#3
\end{tikzpicture}
}

\newcommand{\splittwo}[6]{
\noindent\begin{tikzpicture}[
rect/.style={
	rectangle
}]

\node (Father) [rect] at (0,0) 	{$#4$};
\node (Son1)  [rect,label=right:{$#5$}] at (#1,#2) {};
\node (Son2)  [rect,label=right:{$#6$}] at (#1,#3) {};

\draw [->] (Father.0) -- (Son1);
\draw [->] (Father.0) -- (Son2);
\end{tikzpicture}
}



\newcommand{\splitthree}[8]{
\noindent\begin{tikzpicture}[
rect/.style={
	rectangle
}]

\node (Father) [rect] at (0,0) 	{$#5$};
\node (Son1)  [rect,label=right:{$#6$}] at (#1,#2) {};
\node (Son2)  [rect,label=right:{$#7$}] at (#1,#3) {};
\node (Son3)  [rect,label=right:{$#8$}] at (#1,#4) {};

\draw [->] (Father.0) -- (Son1);
\draw [->] (Father.0) -- (Son2);
\draw [->] (Father.0) -- (Son3);
\end{tikzpicture}
}

\newcommand{\createtransitionsnake}[4]{
\node (#1)  [rect,label=right:{$#4$}] at (#2,#3) {};

\draw [->,decorate,decoration={snake,amplitude=.4mm,segment length=1.2mm}] (Father.0) -- (#1);
}

\newcommand{\splitonesnake}[2]{
\noindent\begin{tikzpicture}[
rect/.style={
	rectangle
}]
\node (Father) [rect,anchor=west] at (0,0) {$#1$};
#2
\end{tikzpicture}
}

\newcommand{\splittwosnake}[3]{
\noindent\begin{tikzpicture}[
rect/.style={
	rectangle
}]
\node (Father) [rect,anchor=west] at (0,0) {$#1$};
#2
#3
\end{tikzpicture}
}

\newcommand{\createtransition}[6]{
\node (#1)  [rect,label=right:{$#6$}] at (#3,#4) {};

\draw [->] (Father.0) -- node[auto,above,sloped] {$#5$} (#1);
}


\newcommand{\splitonelabel}[4]{
\noindent\begin{tikzpicture}[
rect/.style={
	rectangle
}]
\node (Title) [rect,anchor=west] at (0,#1) {$#2$};
\node (Father) [rect,anchor=west] at (0,0) {$#3$};
#4
\end{tikzpicture}
}

\newcommand{\splittwolabel}[5]{
\noindent\begin{tikzpicture}[
rect/.style={
	rectangle
}]
\node (Title) [rect,anchor=west] at (0,#1) {$#2$};
\node (Father) [rect,anchor=west] at (0,0) {$#3$};
#4
#5
\end{tikzpicture}
}

\newcommand{\splitthreelabel}[6]{
\noindent\begin{tikzpicture}[
rect/.style={
	rectangle
}]
\node (Title) [rect,anchor=west] at (0,#1) {$#2$};
\node (Father) [rect,anchor=west] at (0,0) {$#3$};
#4
#5
#6
\end{tikzpicture}
}

\newcommand{\splitfivelabel}[7]{
\noindent\begin{tikzpicture}[
rect/.style={
	rectangle
}]
\node (Title) [rec\Ut,anchor=west] at (0,1.2) {$#1$};
\node (Father) [rect,anchor=west] at (0,0) {$#2$};
#3
#4
#5
#6
#7
\end{tikzpicture}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Proofs
%%%%%%%%%%%%%%%%%%%%%%%%%%

%%% Normalisation

\newcommand{\Vnorm}{\mathord{\rotatebox[origin=c]{270}{\mbox{$\rightsquigarrow$\hspace{1pt}}}}}

\newcommand{\nonded}[2]{\mathsf{nded}(#1,#2)}

\newcommand{\different}[1]{\mathsf{diff}(#1)}

%%% Invariants

\newcommand{\PredWellFormedN}{\mathcal{P}_{form}}
\newcommand{\PredWellFormed}[2]{\PredWellFormedN(#1,#2)}

\newcommand{\PredOrderN}{\mathcal{P}_{order}}
\newcommand{\PredOrder}[2]{\PredOrderN(#1,#2)}

\newcommand{\PredStaticN}{\mathcal{P}_{static}}
\newcommand{\PredStatic}[1]{\PredStaticN(#1)}

\newcommand{\PredAllN}{\mathcal{P}_{all}}
\newcommand{\PredAll}[2]{\PredAllN(#1,#2)}

\newcommand{\PredStcN}{\mathcal{P}_{stc}}
\newcommand{\PredStc}[4]{\PredStcN(#1,#2,#3,#4)}

\newcommand{\PredConseqN}{\mathcal{P}_{cons}}
\newcommand{\PredConseq}[2]{\PredConseqN(#1,#2)}

\newcommand{\PredInitInputN}{\mathcal{P}_{\InitInput}}
\newcommand{\PredInitInput}[2]{\PredInitInputN(#1,#2)}

\newcommand{\PredCorrectFormulaN}{\mathcal{P}_{sound}}
\newcommand{\PredCorrectFormula}[1]{\PredCorrectFormulaN(#1)}

\newcommand{\PredCompleteFormulaN}{\mathcal{P}_{comp}}
\newcommand{\PredCompleteFormula}[2]{\PredCompleteFormulaN(#1,#2)}

\newcommand{\PredVectorN}{\mathcal{P}_{vect}}
\newcommand{\PredVector}[1]{\PredVectorN(#1)}


\newcommand{\Srond}{\mathcal{S}}

\newcommand{\InvD}[1]{\mathsf{InvD}(#1)}
\newcommand{\InvUF}[1]{\mathsf{InvUF}_1(#1)}
\newcommand{\InvUFXOR}[1]{\mathsf{InvUF}_2(#1)}
\newcommand{\InvUFSol}[1]{\mathsf{InvUF}_3(#1)}

\newcommand{\InvConseq}[1]{\mathsf{InvCons}(#1)}
\newcommand{\InvAxiom}[2]{\mathsf{InvAxiom}(#1,#2)}
\newcommand{\InvVec}[1]{\mathsf{InvVec}(#1)}

\newcommand{\FConseq}[2]{\mathsf{FCo}(#1,#2)}
\newcommand{\AFConseq}[2]{\mathsf{AFCo}(#1,#2)}

\newcommand{\InitializeCsys}[2]{\mathsf{InitC}(#1,#2)}

%%% New Terminaison


\newcommand{\setSDF}[2]{\mathsf{set}_{\Solved}(#1,#2)}
\newcommand{\setF}[3]{\mathsf{set}_{F}(#1,#2,#3)}
\newcommand{\setS}[3]{\mathsf{set}_{S}(#1,#2,#3)}

\newcommand{\setRulesUCons}[3]{\mathsf{set}_{\UCons}(#1,#2,#3)}
\newcommand{\setRulesUFact}[3]{\mathsf{set}_{\UFact}(#1,#2,#3)}
\newcommand{\setRulesUConseq}[3]{\mathsf{set}_{\UConseq}(#1,#2,#3)}
\newcommand{\setRulesURew}[2]{\mathsf{set}_{\Rew}(#1,#2)}
\newcommand{\setRulesUFormula}[2]{\mathsf{set}_{\EqFact}(#1,#2)}
\newcommand{\setRulesCons}[2]{\mathsf{set}_{\Cons}(#1,#2)}
\newcommand{\setRulesFact}[2]{\mathsf{set}_{\Fact}(#1,#2)}

\newcommand{\tupleUF}[3]{\mathsf{tuple}_{\USolved}(#1,#2,#3)}
\newcommand{\tupleS}[2]{\mathsf{tuple}_{\mathsf{S}}(#1,#2)}

\newcommand{\measure}[2]{\mu_{gen}(#1,#2)}

\newcommand{\quotientReq}[1]{{#1/{\receq}}}

\newcommand{\Cmgu}[1]{\sigma[#1]}


%%% Old Termination

\newcommand{\TPredSolved}[2]{\mathcal{P}_{Tsol}(#1,#2)}
\newcommand{\TPredDf}[2]{\mathcal{P}_{Tdf}(#1,#2)}
\newcommand{\TPredCons}[4]{\mathcal{P}_{Tcons}(#1,#2,#3,#4)}
\newcommand{\TPredSDF}[1]{\mathcal{P}_{T\Solved}(#1)}
\newcommand{\TPredUF}[2]{\mathcal{P}_{T\USolved}(#1,#2)}

\newcommand{\measureAll}{\mu_{All}}
\newcommand{\measureGen}[6]{\mu_{gen}(#1,#2,#3,#4,#5,#6)}
\newcommand{\measureGenRest}[7]{\mu_{gen}^{#7}(#1,#2,#3,#4,#5,#6)}

\newcommand{\measureGenRestAlone}[1]{\mu_{gen}^{#1}}

\newcommand{\measureSDF}[2]{\mu_{\Solved}(#1,#2)}
\newcommand{\measureUF}[3]{\mu_{\USolved	}(#1,#2,#3)}
\newcommand{\measureT}[3]{T(#1,#2,#3)}



\newcommand{\xrightsquigarrow}[1]{\stackrel{#1}{\rightsquigarrow}}
\newcommand{\xrightsquigarrowstar}[2]{\stackrel{\ \,#1\ \,*}{\rightsquigarrow_{#2}}}

\newcommand{\URConsminus}[3]{\textsc{UseCons}^{-}(#1,#2,#3)}
\newcommand{\URCons}[3]{\textsc{UseCons}(#1,#2,#3)}
\newcommand{\URFactminus}[3]{\textsc{UseRes}^{-}(#1,#2,#3)}
\newcommand{\URFact}[3]{\textsc{UseRes}(#1,#2,#3)}
\newcommand{\URConseq}[3]{\textsc{UseConseq}(#1,#2,#3)}
\newcommand{\URRew}[3]{\textsc{UseRew}(#1,#2,#3)}

\newcommand{\SetUCons}[3]{\textsc{SetUCons}_{#1}^{#2}(#3)}
\newcommand{\SetUFact}[3]{\textsc{SetURes}_{#1}^{#2}(#3)}
\newcommand{\SetUConsMinus}[3]{\textsc{SetUConsMin}_{#1}^{#2}(#3)}
\newcommand{\SetUFactMinus}[3]{\textsc{SetUResMin}_{#1}^{#2}(#3)}

\newcommand{\SetUF}[1]{\textsc{Set}\USolved(#1)}

\newcommand{\SetD}[3]{\textsc{SetD}(#1,#2,#3)}
\newcommand{\SetEq}[3]{\textsc{SetEq}(#1,#2,#3)}
\newcommand{\SetNeq}[2]{\textsc{SetNeq}(#1,#2)}

\newcommand{\SetConseq}[3]{\textsc{SetConseq}_{#1}^{#2}(#3)}

\newcommand{\CConseqS}[3]{\textsc{StConseqS}_{#3}(#1,#2)}
\newcommand{\CConseqF}[2]{\textsc{StConseqF}(#1,#2)}



%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End: